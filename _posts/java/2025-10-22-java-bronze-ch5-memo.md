---
layout: post
title: "Java Bronze 黒本 第5章 メモ"
date: 2025-10-22
last_modified_at: 2025-10-26
categories: [Java]
tags: [Java Bronze, 試験対策, 黒本]
---

現在1周

# 🧩 Java Bronze 黒本 5章一周目 結果

---

## No.1
**選択肢:** D×C  
**結果:** ×  
**ポイント:**
カプセル化は関係するものをひとまとめにすることをいう。フィールドの隠蔽はカプセル化ではなく、データ隠蔽の話。

---

## No.2
**選択肢:** A,B×C,D  
**結果:** ×  
**ポイント:**
カプセル化は関係するデータとそのデータを使う処理をひとまとめにし、ソフトウェアの変更容易性や再利用性を向上させるための設計原則。例えばEmployeeクラスは従業員の名前や従業員番号などをフィールドに持つが、会社名などは持たないほうが望ましい。

---

## No.3
**選択肢:** A  
**結果:** 〇  
**ポイント:**

---

## No.4
**選択肢:** C  
**結果:** 〇  
**ポイント:**

---

## No.5
**選択肢:** C×B  
**結果:** ×  
**ポイント:**
データ隠蔽とは属性の公開範囲を制限すること。データ隠蔽したからと言って必ずしもgetter/setterを用意する必要はない。必要に応じて用意する。

---

## No.6
**選択肢:** A  
**結果:** 〇  
**ポイント:**

---

## No.7
**選択肢:** B  
**結果:** 〇  
**ポイント:**

---

## No.8
**選択肢:** B×E   
**結果:** ×  
**ポイント:**  
```java
public class P {
    public void method() {
        System.out.println("P");
    }
}

public class C extends P {
    public void method(String val) {
        System.out.println(val);
    }
}

public class Main {
    public static void main(String[] args) {
        P obj = new C();
        obj.method("C"); // コンパイルエラー
    }
}
```
この場合、Pクラスのmethod()メソッドは引数なしで定義されているが、Cクラスのmethod(String val)メソッドは引数ありで定義されているためオーバーライドではなくオーバーロードとなり二つのメソッドは別物として扱われる。またmainメソッドでサブクラスを抽象化してスーパークラス型で扱っているため、スーパークラスの定義とは共通しないサブクラス独自のメソッドは無視され存在しないものとして扱われる。
したがって、引数を持たないmethod()メソッドを引数ありで呼び出すことになり、コンパイルエラーが発生する。


---

## No.9
**選択肢:** B×C  
**結果:** ×  
**ポイント:**
ポリモーフィズムには次のような特徴がある。
 - どの型で扱っていたとしても、実際に動作するのはインスタンスそのものである
 - 「使う側」のクラスは、「共通化して扱える型」だけを知っていればよく、「使われる側」のクラスの詳細を知らなくてもよい
 - 「使う側」が「使われる側」の変更の影響を受けることはない(メリット)
 - 影響を受けるのは共通化して使える型が変わったときのみ

 ※ここで言う「使う」とはインスタンス化して使うことを指す。  
 サブクラスの変更がスーパークラスに影響を与えることはないがこれは継承の話であり、ポリモーフィズムの話ではない。

---

## No.10
**選択肢:** A  
**結果:** 〇  
**ポイント:**

---

## No.11
**選択肢:** C,D,F×C,E,F  
**結果:** ×  
**ポイント:**
パッケージ宣言とは、クラスが所属するパッケージを指定するための宣言。パッケージ宣言をすることでクラスへのアクセスを制御できるため、情報隠蔽を実現する手段の一つとなる。


---

## No.12
**選択肢:** B×D  
**結果:** ×  
**ポイント:**
インターフェースには次のような特徴がある。
 - 実装を持たないメソッド宣言のリスト
 - 実装を待たないためインスタンス化できない
 - 実装はインターフェースを実現したクラスが提供する
 - メソッドの宣言以外には、定数のみ定義できる

---

## No.13
**選択肢:** A,B  
**結果:** 〇  
**ポイント:**

---

## No.14
**選択肢:** B×D  
**結果:** ×  
**ポイント:**
has-a関係とは、あるクラスが他のクラスのインスタンスをフィールドとして持つ関係のこと。例えば、CarクラスがEngineクラスのインスタンスをフィールドとして持つ場合、CarクラスはEngineクラスを「持っている」(has-a)関係にあると言える。
```java
public class Engine {
    // エンジンに関するフィールドやメソッド
}   
public class Car {
    private Engine engine; // CarクラスはEngineクラスを持っている

    public Car() {
        this.engine = new Engine(); // CarのコンストラクタでEngineのインスタンスを生成
    }

    // Carクラスに関するフィールドやメソッド
}
```
Car has-a Engine という関係になる。

---

## No.15
**選択肢:** A,D×B,C  
**結果:** ×  
**ポイント:**
is-a関係とは、あるクラスが他のクラスを継承している関係のこと。例えば、DogクラスがAnimalクラスを継承している場合、DogクラスはAnimalクラスの一種であると言える。下位から上位への分類の関係を表す。
```java
// スーパークラス(インターフェース)
public interface Animal {
    // 動物に関するフィールドやメソッド
}   
// サブクラス(抽象クラス)
public abstract class Mammal implements Animal {
    // 哺乳類に関するフィールドやメソッド
}
// サブクラス(具象クラス)
public class Dog extends Mammal {
    // 犬に関するフィールドやメソッド
}
```
Dog is-a Mammal, Dog is-a Animal, Mammal is-a Animal という関係になる。


---

## No.16
**選択肢:** C  
**結果:** 〇  
**ポイント:**

---

## No.17
**選択肢:** B  
**結果:** 〇  
**ポイント:**
具象クラスは実行するためのクラス。すべてのメソッドが実装済みでなければならない。具象クラスはインスタンス化できる。具象クラスも継承できるが継承させるために作るわけではない。

抽象クラスは継承を前提としたクラス。インスタンス化できない。具象クラスとインターフェースの両方の性質を併せ持つ♡。抽象クラスは、共通の属性やメソッドを持つ複数のサブクラスに対して、共通の基盤を提供するために使用される。抽象クラスは、抽象メソッドを含むことができ、抽象メソッドはサブクラスで実装される必要がある。

---

### ✅ 1週目結果
正答率: 47% (8/17問)  
**傾向メモ:**
 - カプセル化、データ隠蔽の理解不足
 - ポリモーフィズムの理解不足
 - is-a, has-aの理解不足
 - 抽象クラス、具象クラスの理解不足
 - インターフェースの理解不足

