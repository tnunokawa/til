---
layout: post
title: "Java Bronze 黒本 第7章 メモ"
date: 2025-11-05
last_modified_at: 2025-11-05
categories: [Java]
tags: [Java Bronze, 試験対策, 黒本]
---

現在1周

# 🧩 Java Bronze 黒本 7章1周目 結果

---

## No.1
**選択肢:** B  
**結果:** 〇  
**ポイント:**

---

## No.2
**選択肢:** E  
**結果:** 〇  
**ポイント:**

---

## No.3
**選択肢:** D×C  
**結果:** ×  
**ポイント:**
スーパークラスを継承したサブクラスをインスタンス生成するとスーパークラスのインスタンスが先に生成され、あとから生成されたサブクラス分の差分のインスタンスと結合することでサブクラスのインスタンスが完成する。もしスーパークラスとサブクラスで共通したフィールドがあったとしても、スーパークラスのフィールドとサブクラスのフィールドは別物として扱われる。そのため、スーパークラスのフィールドを初期化してもサブクラスのフィールドには影響しない。
```java
public class Super {
    private int value ;
    public void setValue(int value) {
        this.value = value;
    }
}
public class Sub extends Super {
    private int value ;
    public int getValue() {
        return this.value;
    }
}
public class Main {
    public static void main(String[] args) {
        Sub sub = new Sub();
        sub.setValue(100); // Superクラスのvalueに100をセット
        System.out.println(sub.getValue()); // Subクラスのvalueは初期化されていないので0が出力される
    }
}
```
↓
```
0
```
この例ではスーパークラスのフィールドがprivateで宣言されているため、サブクラスから直接アクセスすることはできないし、サブクラスのフィールドとは別物として扱われる。もしスーパークラスのフィールドがpublicやprotectedで宣言されていたとしても、同様にスーパークラスとサブクラスのフィールドは別物として扱われるが、サブクラスで同名のフィールドを宣言しなければサブクラスのthis.value=super.valueとなり、スーパークラスのフィールドにアクセスできる。スーパークラスのフィールド名と同じ名前でサブクラスのフィールドを宣言することをシャドーイングという（非推奨）。

---

## No.4
**選択肢:** B,C  
**結果:** 〇  
**ポイント:**
サブクラスのインスタンスがスーパークラスから引き継げないものは以下の通り。
- コンストラクタ
- privateメンバー（フィールド、メソッド）  
publicなメソッドはサブクラスがオーバーライドしない限り継承可能。

---

## No.5
**選択肢:** B×C  
**結果:** ×
**ポイント:**
サブクラスをインスタンス化するときスーパークラスもインスタンス化されるため、スーパークラスのコンストラクタが先に実行される。スーパークラスのコンストラクタが引数なしの場合は自動的に呼び出されるが、引数ありの場合は明示的にsuper(引数)で呼び出す必要がある。

---

## No.6
**選択肢:** D×A  
**結果:** ×  
**ポイント:**
スーパークラスに明示的に引数ありコンストラクタしか定義されていない場合、サブクラスのコンストラクタでsuper(引数)を使ってスーパークラスのコンストラクタを明示的に呼び出す必要がある。呼び出すコードがない場合コンパイルエラーになる。もしスーパークラスに引数なしコンストラクタが定義されていれば、サブクラスのコンストラクタでsuper(引数)を使って明示的に呼び出さなくても自動的に引数なしコンストラクタが呼び出される（コンパイル時に自動的にsuper()が挿入される）。
```java
public class Super {
    public Super(int value) {
        System.out.println("Super: " + value);
    }
}   
public class Sub extends Super {
    public Sub() {
        super(100); // スーパークラスの引数ありコンストラクタを明示的に呼び出す必要がある
        System.out.println("Sub");
    }
}
```


---

## No.7
**選択肢:** B  
**結果:** 〇  
**ポイント:**
コンストラクタチェーンとは、サブクラスのコンストラクタが呼び出されたときに、スーパークラスのコンストラクタも順番に呼び出される仕組みのこと。サブクラスのコンストラクタが実行される前にスーパークラスのコンストラクタが実行されるため、スーパークラスのフィールドが初期化されてからサブクラスのフィールドが初期化される。これにより、サブクラスはスーパークラスの機能を正しく利用できるようになる。
スーパークラスのコンストラクタが引数なしの場合は自動的に呼び出される。しかし、サブクラスのコンストラクタ内でthis();など明示的に呼び出されていた場合、そのコンストラクタにsuper();が挿入されるとコンパイルエラーになる(コンストラクタのthisやsuperはコンストラクタの先頭にしか書けない)ため、コンパイラはthis();で呼び出した先のコンストラクタにsuper();を挿入する。

```java
public class Super {
    public Super() {
        System.out.println("Superのコンストラクタ");
    }
}
public class Sub extends Super {
    public Sub() {
        this(0); // 引数ありコンストラクタを呼び出す
    }
    public Sub(int value) {
        super(); // ここでsuper()が挿入される(明示的に書かなくてもコンパイラが挿入する)
        System.out.println("Subの引数ありコンストラクタ: " + value);
    }
}
public class Main {
    public static void main(String[] args) {
        new Sub();
    }
}
```
↓
```
Superのコンストラクタ
Subの引数ありコンストラクタ: 0
```

---

## No.8
**選択肢:** E   
**結果:** 〇  
**ポイント:**  

---

## No.9
**選択肢:** D  
**結果:**   
**ポイント:**

---

## No.10
**選択肢:** A  
**結果:**   
**ポイント:**

---

## No.11
**選択肢:** C×A  
**結果:** ×  
**ポイント:**
サブクラスでオーバーライドしたメソッドの例外はなくても良い。ただしもし例外を出す場合はスーパークラスのメソッドの例外と同じ型か、そのサブタイプである必要がある。
※オーバーライド:スーパークラスで定義されたメソッドをサブクラスで再定義すること。
```java
public class Super {
    public void method() throws IOException {
        // 何らかの処理
    }
}
public class Sub extends Super {
    @Override
    public void method() throws FileNotFoundException { // OK: FileNotFoundExceptionはIOExceptionのサブタイプ
        // 何らかの処理
    }
}
```

---

## No.12
**選択肢:** C  
**結果:** 〇  
**ポイント:**

---

## No.13
**選択肢:** A,C,E×B,C,E  
**結果:** ×  
**ポイント:**
インターフェースとは「これ装するなら、このメソッドは絶対に作ってね！」と義務を定める仕組み。他のクラスで実装されることを前提として作られている。そのため、インターフェースのフィールドはコンパイラにより暗黙的にpublic、static、finalで修飾される。
protectedは公開するという目的に合わないので×。

---

## No.14
**選択肢:** A,D×C,D  
**結果:** ×  
**ポイント:**
インターフェースに定義できるのは定数フィールドと抽象メソッド。情報隠蔽のうち公開部分をインターフェースとして定めるため、そのメソッドはpublicでなければならない。また具体的な処理を持たないメソッドは具体的な処理を持つメソッドと区別するためabstractで修飾しなければならない。そのためインターフェースに定義した抽象メソッドはコンパイラによって暗黙的にpublic abstractで修飾される。

---

## No.15
**選択肢:** A,B,E×B,D,E  
**結果:** ×  
**ポイント:**
クラスは複数のインターフェースを実現できる。インターフェースは複数のインターフェースを継承できる。クラスは複数のクラスを継承できない。
```java
public interface A {
    void methodA();
}
public interface B extends A {
    void methodB();
}
public class C implements A, B { // 複数のインターフェースを実現できる
    @Override
    public void methodA() {
        // 実装
    }
    @Override
    public void methodB() {
        // 実装
    }
}
```

---

## No.16
**選択肢:** A,B?  
**結果:**   
**ポイント:**

---

## No.17
**選択肢:** B?  
**結果:**   
**ポイント:**

---

## No.18
**選択肢:** A,D,E  
**結果:**   
**ポイント:**

---

## No.19
**選択肢:** A,B  
**結果:**   
**ポイント:**  

---

### ✅ 1週目結果
正答率: % (/問)  
**傾向メモ:**
 - 